## 01背包

一个物品只可以拿一次

```cpp
if(w[i]<j){//可以装
	dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
    // dp[i-1][j-w[i]] 表示在买第 i 件商品前背包的情况：未买第i件商品 背包容量为 j-w[i] ，商品种类就为 i-1 ，价值为dp[i-1][j-w[i]], 而在买了商品后：容量变为了j ，价值也加上了 v[i] ;
}else{
    dp[i][j]=dp[i-1][j];
}
```

## 完全背包

```cpp
#include<iostream>
const int N=2e5;
int dp[N][N];
int v[N];
int w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++) {
       cin>>w[i]>>v[i];
    }
    
    for (int i = 1; i <= n; i ++ )// 物品种类
        for (int j = 1; j <= m; j ++ ) {// 背包容量
            dp[i][j] = dp[i - 1][j]; // 一开始未加入第i个商品,价值肯定是 和 dp[i-1][j]相同;表示没开始加入第i种商品
            if (v[i] > j) {  // 防止数组越界
                continue;
            }
            for (int k = 0; k * v[i] <= j; k++) { // 在不超过容量的情况下,添加k个物品i
                dp[i][j] = max(dp[i][j], f[i - 1][j - k * w[i]] + k * v[i]);
             //  dp[i][j] 表示当前,不加入物品i(第一轮)或者加入少一个i(后面几轮)的价值
             //  dp[i - 1][j - k * w[i]] + k * v[i]) 表示加入 k 个 i 物品的价值 
            }
        }
    cout<<dp[m][n];
}

```



一本物品无限次拿

```cpp
if(w[i]<j){//可以装
	dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i]);
    // dp[i][j]=max(dp[i-1][j](表示第i个物品一件都没要),  dp[i][j-w[i]] (表示当前未买第i件物品的价值....),   dp[i][j-w[i]]+v[i])
    // dp[i][j-w[i]] 表示如果可以装第i件商品就一直装
}else{ 
    dp[i][j]=dp[i-1][j];
}
```



## 多重背包

**01背包** 和 **完全背包** 的结合

