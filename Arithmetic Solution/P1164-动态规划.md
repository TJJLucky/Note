# 动态规划


```cpp
#include<iostream>
using namespace std;
const long long N = 1e5 + 9;
int dp[1000][1000];// dp[i][j] 表示前 i 个商品花费 j 元的方法数
int a[N];
int main() {
	long long m, n,ans=0;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];//第i个物品的代价
	for (int i = 0; i <= n; i++) {
		dp[i][0] = 1;//花费 0 元购买物品 的方法为 1;因为花费0元的方法,有且仅有一种,那就是都不买
	}
	for (int i = 1; i <= n; i++) {// 从第一个物品开始历遍
		for (int j = 1; j <= m; j++) {// 历遍 花费的钱(代价)的数目
            dp[i][j] += dp[i - 1][j];
            if (j >= a[i]) {
				dp[i][j] += dp[i - 1][j - a[i]];
			}
		}
	}
	cout << dp[n][m];
	return 0;
}
```

```cpp
dp[i][j] += dp[i - 1][j]; //首先暂且先不购买第 i 件商品, 那么此时的方法数
if (j >= a[i]) {     
	dp[i][j] += dp[i - 1][j - a[i]];
}
```

 $dp[ i ][ j ]$ 表示 购买前 $i$ 个商品花费为 $ j $ 的方法数.

$dp[i][j]$一共有两种情况:

1. 买第 $i$ 件商品 : $dp[i][j] += dp[i - 1][j - a[i]]$  相当于 在 前 $i-1$ 件商品 花费 $j-a[i]$  元 的==基础之上== 卖下了花费$a[i]$ 元的 $i$ 这件商品(前提是$j>= a[i]$ 可以买)
2. 不买第 $i$ 件商品:$dp[i][j] += dp[i - 1][j] $ 那么就表示 前$i$ 件商品 和前 $i-1$ 件商品一样 花费了 $j$ 元

因为求的是方法,所以两种情况都要加上, 其中不买 $i$ 这件商品 这种情况一定存在

最后输出 $dp[n][m]$ ,即一共 $n$ 件商品 花费 m元的方法

# 优化为一维数组

为何可以优化？：

​	每次循环只用到了 $i$ 的上一个 $i-1$ 

所以由 $dp[i][j]$ 可以变为 $dp[j]$ 

```c++
#include<iostream>
using namespace std;
const long long N = 1e5 + 9;
int dp[N];
int a[N];
int main() {
	long long m, n, ans = 0;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
		dp[0]= 1;//表示最初始的那个，第一个商品花费0元的方法为1；
	for (int i = 1; i <= n; i++) {
		for (int j = m; j >= 1; j--) {//注意这里要反过来应为dp[j-a[i]]可能已经改变了
         	//这里省略了一步就是 dp[j]=dp[j] 这表示 不买的情况,下一个和上一个的方法数是一样的
			if (j >= a[i]) {
				dp[j] += dp[j - a[i]];//逐渐迭代
			}
		}
	}
	cout << dp[m];
	return 0;
}
```





$line:15$ 一维的 $dp[j] += dp[j - a[i]]$  对比 二维的 $dp[i] [j] += dp[i - 1] [j - a[i]]$	

- $dp[j] += dp[j - a[i]]$ , 表示 花费$j-a[i]$元可以卖下前$i-1$个商品 的方法数的基础上 买下$i$这件商品的方法数,直接覆盖掉 $dp:i-1$的
- 所以要倒过来历遍$j:(m\to 1)$,以防 $dp[j-a[i]]$ 被覆盖了